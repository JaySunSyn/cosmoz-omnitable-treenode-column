<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../cosmoz-omnitable/cosmoz-omnitable-column-behavior.html">

<link rel="import" href="../cosmoz-treenode/cosmoz-treenode.html">

<!--
`cosmoz-omnitable-treenode-column`
cosmoz-omnitable column to display a tree node

@demo demo/index.html
-->

<dom-module id="cosmoz-omnitable-treenode-column">
	<template>
		<template id="data-template">
			<cosmoz-treenode hide-from-root="[[ _hideFromRoot ]]" show-max-nodes="[[ showMaxNodes ]]"
				key-type="[[ valueType ]]" key-id="[[ get(valuePath, item) ]]" owner-tree="[[ ownerTree ]]">
			</cosmoz-treenode>
		</template>

		<template id="edit-data-template">
		</template>

		<template id="header-template">
			<paper-input label="[[ title ]]" value="{{ filter }}"></paper-input>
		</template>

  </template>

  <script>
	Polymer({

		is: 'cosmoz-omnitable-treenode-column',

		properties: {
			ownerTree: {
				type: Cosmoz.Tree
			},

			/**
			 * Ask for a list of values
			 */
			bindValues: {
				type: Boolean,
				readOnly: true,
				value: true
			},

			showMaxNodes: {
				type: Number
			},

			/**
			 * If displayed node share a common path from root, this property indicates wether this common
			 * path should be replaced by an ellipsis.
			 */
			hideCommonPath: {
				type: Boolean,
				value: false
			},

			/**
			 * The type of value present in valuePath (nodeId or pathLocator)
			 * 'unknown' if cosmoz-treenode should figure it out
			 */
			valueType: {
				type: String,
				value: 'unknown'
			},

			_hideFromRoot: {
				type: Number,
				value: 0
			}
		},

		behaviors: [
			Cosmoz.OmnitableColumnBehavior
		],

		observers: [
			'_valuesChanged(values, ownerTree)'
		],

		getComparableValue: function (item, valuePath) {
			var val = this.ownerTree.getPathString(this.get(valuePath, item), '/');
			return val;
		},

		// Implement filtering using treenode-navigator
		getFilterFn: function () {
			if (!this.filter) {
				return;
			}
			return this._applySingleFilter.bind(this, this.filter);
		},

		_applySingleFilter: function (filterString, item) {
			var value = this.getComparableValue(item, this.valuePath).toLowerCase();
			return value.indexOf(filterString.toLowerCase()) >= 0;
		},

		_valueIsGuid: function (input) {
			return input.length === 36;
		},

		_valuesChanged: function (values, ownerTree) {
			if (!values || !Array.isArray(values) || values.length == 0) {
				return;
			}

			var hideFromRoot = 0,
				paths = values.map(function (value) {
					console.log(value, ownerTree);
					var pathLocator = value;
					if (this._valueIsGuid(value)) {
						pathLocator = ownerTree.findNodeById(nodeId).pathLocator;
					}
					// otherwise path locator
					return pathLocator.split('.')
				}, this),
				smallestPath = paths.reduce(function (agg, part) {
					if (agg === undefined || part.length < agg.length) {
						return part;
					}
					return agg;
				});

			smallestPath.splice(-1);

			smallestPath.every(function (sPathPart, sppIndex) {
				var allSame = paths.every(function (path) {
					return path[sppIndex] === sPathPart;
				});
				if (allSame) {
					hideFromRoot += 1;
				}
				return allSame;
			});

			console.log('hideFromRoot', hideFromRoot);

			/* while (smallestPath.length > 0) {
				if (paths.some(function (path) {
					return !this._arrayStartsWith(path, smallestPath);
				}, this)) {
					smallestPath.splice(-1);
				} else {
					break;
				}
			} */

			this.set('_hideFromRoot', hideFromRoot);
		},

		/**
		 * Returns true if first items of array are the same as those in searchArray
		 */
		_arrayStartsWith(array, searchArray) {
			var i;
			for (i = 0; i < searchArray.length; i+=1) {
				if (array[i] !== searchArray[i]) {
					return false;
				}
			}
			return true;
		}

	});
  </script>
</dom-module>
